{"version":3,"file":"bundle.js","sources":["webpack:///./src/scenes/PlayScene.ts","webpack:///./src/components/GemGrid.ts","webpack:///./src/components/Gem.ts","webpack:///./src/components/MatchSequenceHelper.ts","webpack:///./src/components/Grid.ts","webpack:///./src/components/Score.ts","webpack:///./src/components/Resources.ts","webpack:///./src/components/Events.ts","webpack:///./src/main.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Resources_1 = require(\"../components/Resources\");\n\nconst GemGrid_1 = require(\"../components/GemGrid\");\n\nconst Score_1 = require(\"../components/Score\");\n\nconst Events_1 = require(\"../components/Events\");\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super({\n      key: 'GameScene'\n    });\n\n    this.check = () => {\n      this.input.mouse.enabled = false;\n      let match = this.grid.check();\n\n      if (match.length) {\n        let match = this.grid.check();\n        this.grid.remove(match).then(() => {\n          match.forEach((e, idx) => this.score.inc(e.list.length * e.list.length + (match.length - idx)));\n          this.grid.repopulate();\n        });\n        setTimeout(this.check, 2000);\n      } else {\n        this.checkGameover();\n      }\n    };\n\n    this.checkGameover = () => {\n      if (this.grid.isGameOver()) {\n        if (this.lifes) {\n          this.input.mouse.enabled = true;\n          this.lifes--;\n          this.grid.replaceBadrock();\n          this.check();\n        } else {\n          this.grid.disableGems();\n          let style = {\n            font: \"bold 50px Courier\",\n            fill: \"#fff\",\n            boundsAlignH: \"center\",\n            boundsAlignV: \"middle\",\n            stroke: '#000000',\n            strokeThickness: 4\n          };\n          let text = this.add.text(this.background.width / 2, this.background.height / 2, \"GAME OVER!\", style);\n          text.setOrigin(0.5, 0.5);\n        }\n      } else {\n        this.input.mouse.enabled = true;\n      }\n    };\n  }\n\n  preload() {\n    Resources_1.Resources.load(this, Resources_1.Resources.background);\n    Resources_1.Resources.load(this, Resources_1.Resources.diamondBlue);\n    Resources_1.Resources.load(this, Resources_1.Resources.diamondRed);\n    Resources_1.Resources.load(this, Resources_1.Resources.diamondGreen);\n    Resources_1.Resources.load(this, Resources_1.Resources.diamondYellow);\n    Resources_1.Resources.load(this, Resources_1.Resources.badrock);\n    Resources_1.Resources.load(this, Resources_1.Resources.scorePanel);\n  }\n\n  create() {\n    this.lifes = 1;\n    this.background = this.add.image(215, 215, Resources_1.Resources.background.name);\n    this.score = new Score_1.Score({\n      scene: this,\n      x: 215,\n      y: 485\n    });\n    this.grid = new GemGrid_1.GemGrid({\n      x: 40,\n      y: 40,\n      scene: this\n    });\n    this.check();\n    this.input.mouse.capture = true;\n    this.sys.events.on(Events_1.Events.gemClick, gem => {\n      this.gem = gem;\n    });\n  }\n\n  update(time, delta) {\n    if (!this.input.mouse.enabled) {\n      return;\n    }\n\n    let pointer = this.input.activePointer;\n\n    if (this.gem) {\n      this.gem.sprite.x = pointer.position.x;\n      this.gem.sprite.y = pointer.position.y;\n      let overlapItem = this.grid.overLappingWith(this.gem, pointer.position);\n\n      if (overlapItem) {\n        this.input.mouse.enabled = false;\n        this.grid.swapPosition(this.gem, overlapItem).then(() => {\n          let checkList = this.grid.check();\n\n          if (checkList.length) {\n            this.check();\n          } else {\n            this.grid.swapPosition(this.gem, overlapItem).then(() => this.input.mouse.enabled = true);\n          }\n\n          ;\n          this.gem = null;\n        });\n      }\n    }\n\n    if (this.gem && !pointer.isDown) {\n      this.gem.backToGridPosition();\n      this.gem = null;\n    }\n  }\n\n}\n\nexports.default = GameScene;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scenes/PlayScene.ts\n// module id = 1078\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Gem_1 = require(\"./Gem\");\n\nconst MatchSequenceHelper_1 = require(\"./MatchSequenceHelper\");\n\nconst Grid_1 = require(\"./Grid\");\n\nconst Resources_1 = require(\"./Resources\");\n\nconst SPACING = 70;\n\nclass GemGridConstructor {}\n\nclass GemGrid {\n  constructor(cObj) {\n    this.check = () => {\n      let matchListGrid = [];\n      this.searchSequenceOnGrid(this.grid.rows, matchListGrid);\n      this.searchSequenceOnGrid(this.grid.columns, matchListGrid);\n      return matchListGrid;\n    };\n\n    this.remove = matchList => {\n      matchList.forEach(matchItem => {\n        let gemList = matchItem.list;\n        gemList.forEach(gem => {\n          let coordenate = {\n            column: gem.column,\n            row: gem.row\n          };\n\n          if (this.grid.cell(coordenate) != null) {\n            gem.destroy();\n          }\n\n          ;\n          this.grid.setCell(coordenate, null);\n        });\n      });\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.fall();\n          resolve();\n        }, 500);\n      });\n    };\n\n    this.repopulate = () => {\n      this.grid.columns.forEach((column, cIdx) => {\n        column.forEach((item, lIdx) => {\n          if (!item) {\n            let xBegin = cIdx * SPACING + this.x;\n            let yBegin = -((column.length - lIdx) * SPACING);\n            let newItem = new Gem_1.Gem({\n              column: cIdx,\n              row: lIdx,\n              scene: this.scene,\n              visible: true,\n              x: xBegin,\n              y: yBegin\n            });\n            let yFinal = lIdx * SPACING + this.y;\n            this.grid.setCell({\n              column: cIdx,\n              row: lIdx\n            }, newItem);\n            newItem.fallTo(yFinal, newItem.row);\n          }\n\n          ;\n        });\n      });\n    };\n\n    this.overLappingWith = (gem, position) => {\n      let possibleMoves = this.calcPossibleMoves(gem);\n\n      for (let i = 0; i < possibleMoves.length; i++) {\n        let m = possibleMoves[i];\n        let overlapItem = this.grid.cell({\n          column: m.column,\n          row: possibleMoves[i].row\n        });\n\n        if (overlapItem && overlapItem.type != Resources_1.Resources.badrock.name) {\n          let width = overlapItem.sprite.width / 2 - 10;\n          let height = overlapItem.sprite.height / 2 - 10;\n          let xBoundary = [overlapItem.x - width, overlapItem.x + width];\n          let yBoundary = [overlapItem.y - height, overlapItem.y + height];\n          let xOverlapping = position.x > xBoundary[0] && position.x < xBoundary[1];\n          let yOverlapping = position.y > yBoundary[0] && position.y < yBoundary[1];\n          let isOverlapping = xOverlapping && yOverlapping;\n\n          if (isOverlapping) {\n            return overlapItem;\n          }\n\n          ;\n        }\n\n        ;\n      }\n\n      ;\n    };\n\n    this.swapPosition = (gem1, gem2, doMoveSprite = true) => {\n      let x1 = gem1.x;\n      let y1 = gem1.y;\n      let column1 = gem1.column;\n      let row1 = gem1.row;\n      let m1 = {\n        column: column1,\n        row: row1\n      };\n      let x2 = gem2.x;\n      let y2 = gem2.y;\n      let column2 = gem2.column;\n      let row2 = gem2.row;\n      let m2 = {\n        column: column2,\n        row: row2\n      };\n      this.grid.setCell(m2, gem1);\n      this.grid.setCell(m1, gem2);\n      gem1.moveTo({\n        x: x2,\n        y: y2,\n        row: row2,\n        column: column2\n      }, doMoveSprite);\n      gem2.moveTo({\n        x: x1,\n        y: y1,\n        row: row1,\n        column: column1\n      }, doMoveSprite);\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n        }, 500);\n      });\n    };\n\n    this.isGameOver = () => {\n      /*\r\n          This is not a very optimized solution since we will have a lot of\r\n          overlapping check, but it will still been fast sice we don't have\r\n          that many columns and rows\r\n       */\n      for (let c = 0; c < this.grid.columns.length; c++) {\n        let column = this.grid.columns[c];\n\n        for (let r = 0; r < column.length; r++) {\n          let gem = this.grid.cell({\n            column: c,\n            row: r\n          });\n          let possibleMoves = this.calcPossibleMoves(gem); // check if any move will result in a match\n\n          for (let i = 0; i < possibleMoves.length; i++) {\n            let m = possibleMoves[i];\n            let swapGem = this.grid.cell({\n              column: m.column,\n              row: possibleMoves[i].row\n            });\n\n            if (!(gem.type == Resources_1.Resources.badrock.name || swapGem.type == Resources_1.Resources.badrock.name)) {\n              let matchListGrid = [];\n              this.swapPosition(gem, swapGem, false);\n              this.searchSequenceOnGrid([this.grid.row(gem.row)], matchListGrid);\n              this.searchSequenceOnGrid([this.grid.column(gem.column)], matchListGrid);\n\n              if (matchListGrid.length) {\n                // if yes, just go on.\n                this.swapPosition(gem, swapGem);\n                return false;\n              }\n\n              this.swapPosition(gem, swapGem);\n            }\n          }\n        }\n      } // if no move will result in a match, the game is over!\n\n\n      return true;\n    };\n\n    this.replaceBadrock = () => {\n      Gem_1.Gem.GENERATE_BADROCK = false;\n      this.grid.columns.forEach((column, cIdx) => {\n        column.forEach((item, lIdx) => {\n          if (item.type == Resources_1.Resources.badrock.name) {\n            item.destroy();\n            let xBegin = cIdx * SPACING + this.x;\n            let yBegin = -((column.length - lIdx) * SPACING);\n            let newItem = new Gem_1.Gem({\n              column: cIdx,\n              row: lIdx,\n              scene: this.scene,\n              visible: true,\n              x: xBegin,\n              y: yBegin\n            });\n            let yFinal = lIdx * SPACING + this.y;\n            this.grid.setCell({\n              column: cIdx,\n              row: lIdx\n            }, newItem);\n            newItem.fallTo(yFinal, newItem.row);\n          }\n\n          ;\n        });\n      });\n      Gem_1.Gem.GENERATE_BADROCK = true;\n    };\n\n    this.disableGems = () => {\n      this.grid.columns.forEach(column => {\n        column.forEach(item => {\n          console.log(\"clock aqui\");\n          item.disableClick();\n        });\n      });\n    };\n\n    this.searchSequenceOnGrid = (grid, matchListGrid) => {\n      grid.forEach(e => {\n        let matchList = this.searchSequenceOnList(e, 0, []);\n\n        if (matchList.length) {\n          matchListGrid.push(...matchList);\n        }\n\n        ;\n      });\n    };\n\n    this.searchSequenceOnList = (list, index, matchList) => {\n      let item = list[index];\n      let matchItem = matchList.filter(e => e.type == item.type);\n\n      if (matchItem.length) {\n        matchItem[0].add(item);\n      } else if (item.type != Resources_1.Resources.badrock.name) {\n        let newMatchItem = new MatchSequenceHelper_1.MatchSequenceHelper(item);\n        matchList.push(newMatchItem);\n      }\n\n      ;\n\n      if (index < list.length - 1) {\n        index++;\n        return this.searchSequenceOnList(list, index, matchList);\n      } else {\n        matchList = matchList.filter(e => {\n          e.end();\n          return e.size();\n        });\n        return matchList;\n      }\n\n      ;\n    };\n\n    this.fall = () => {\n      this.grid.sort((a, b) => {\n        let aValue = a ? 1 : -1;\n        let bValue = b ? 1 : -1;\n        return aValue - bValue;\n      });\n      this.grid.columns.forEach(column => {\n        column.forEach((item, index) => {\n          if (item) {\n            item.fallTo(index * SPACING + this.y, index);\n          }\n        });\n      });\n    };\n\n    this.calcPossibleMoves = gem => {\n      let maxBoudaryColumns = this.grid.columns.length;\n      let maxBoudaryRows = this.grid.rows.length;\n      let moves = [];\n\n      if (gem.column - 1 > -1) {\n        //move to the left\n        moves.push({\n          column: gem.column - 1,\n          row: gem.row\n        });\n      }\n\n      ;\n\n      if (gem.column + 1 < maxBoudaryColumns) {\n        //move to the right\n        moves.push({\n          column: gem.column + 1,\n          row: gem.row\n        });\n      }\n\n      ;\n\n      if (gem.row - 1 > -1) {\n        //move to the top\n        moves.push({\n          column: gem.column,\n          row: gem.row - 1\n        });\n      }\n\n      ;\n\n      if (gem.row + 1 < maxBoudaryRows) {\n        //move to the bottom\n        moves.push({\n          column: gem.column,\n          row: gem.row + 1\n        });\n      }\n\n      ;\n      return moves;\n    };\n\n    this.grid = new Grid_1.Grid({\n      column: 6,\n      row: 6\n    });\n    this.grid.populate(coordenate => {\n      let x = coordenate.column * SPACING + cObj.x;\n      let y = coordenate.row * SPACING + cObj.y;\n      let column = coordenate.column;\n      let row = coordenate.row;\n      let item = new Gem_1.Gem({\n        column,\n        row,\n        scene: cObj.scene,\n        visible: true,\n        x,\n        y\n      });\n      return item;\n    });\n    this.x = cObj.x;\n    this.y = cObj.y;\n    this.scene = cObj.scene;\n    Gem_1.Gem.GENERATE_BADROCK = true;\n  }\n\n}\n\nexports.GemGrid = GemGrid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/GemGrid.ts\n// module id = 1079\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Resources_1 = require(\"./Resources\");\n\nconst Events_1 = require(\"./Events\");\n\nconst GEM_LIST = [Resources_1.Resources.diamondBlue, Resources_1.Resources.diamondRed, Resources_1.Resources.diamondGreen, Resources_1.Resources.diamondYellow, Resources_1.Resources.badrock];\n\nclass GemConstructor {}\n\nclass MoveTo {}\n\nclass Gem {\n  constructor(cObj) {\n    this.disabled = false;\n\n    this.moveTo = (obj, moveSprite = true) => {\n      this._x = obj.x;\n      this._y = obj.y;\n      this._row = obj.row;\n      this._column = obj.column;\n\n      if (moveSprite) {\n        this.backToGridPosition();\n      }\n\n      ;\n    };\n\n    this.fallTo = (y, row) => {\n      this._row = row;\n      this._y = y;\n      this.tween = this.scene.add.tween({\n        targets: [this.sprite],\n        ease: 'Sine.Quadratic.Out',\n        duration: 200 + y - this.sprite.y,\n        delay: 0,\n        y: {\n          getStart: () => this.sprite.y,\n          getEnd: () => y\n        }\n      });\n    };\n\n    this.backToGridPosition = () => {\n      this.tween = this.scene.add.tween({\n        targets: [this.sprite],\n        ease: 'Sine.easeInOut',\n        duration: 100 + (Math.abs(this.sprite.y - this._y) + Math.abs(this.sprite.x - this._y)) / 2,\n        delay: 0,\n        y: {\n          getStart: () => this.sprite.y,\n          getEnd: () => this._y\n        },\n        x: {\n          getStart: () => this.sprite.x,\n          getEnd: () => this._x\n        }\n      });\n    };\n\n    this.disableClick = () => {\n      /*\r\n          The only line really working here is the last one\r\n          idk why, by on mobile especially, the first 2 has no effect\r\n      */\n      this.sprite.setInteractive(false);\n      this.sprite.on(\"pointerdown\", () => {});\n      this.disabled = true;\n    };\n\n    this.destroy = () => {\n      this.tween = this.scene.add.tween({\n        targets: [this.sprite],\n        ease: 'Sine.easeInOut',\n        duration: 500,\n        delay: 0,\n        alpha: {\n          getStart: () => this.sprite.alpha,\n          getEnd: () => 0\n        },\n        scaleX: {\n          getStart: () => this.sprite.scaleX,\n          getEnd: () => 0.1\n        },\n        scaleY: {\n          getStart: () => this.sprite.scaleY,\n          getEnd: () => 0.1\n        },\n        onComplete: () => {\n          this.sprite.destroy();\n        }\n      });\n    };\n\n    let type = 0;\n\n    if (Gem.GENERATE_BADROCK) {\n      type = Phaser.Math.Between(0, 4);\n\n      if (GEM_LIST[type].name == Resources_1.Resources.badrock.name) {\n        type = Phaser.Math.Between(0, 4);\n      }\n    } else {\n      type = Phaser.Math.Between(0, 3);\n    }\n\n    this.type = GEM_LIST[type].name;\n    this.sprite = cObj.scene.add.image(cObj.x, cObj.y, this.type);\n    this.sprite.visible = cObj.visible;\n    this.sprite.name;\n    this.sprite.setInteractive();\n\n    if (this.type != Resources_1.Resources.badrock.name) {\n      this.sprite.on(\"pointerdown\", () => {\n        if (!this.disabled) {\n          this.scene.children.bringToTop(this.sprite);\n          this.scene.sys.events.emit(Events_1.Events.gemClick, this);\n        }\n      });\n    }\n\n    this._column = cObj.column;\n    this._row = cObj.row;\n    this.scene = cObj.scene;\n    this._x = cObj.x;\n    this._y = cObj.y;\n  }\n\n  get column() {\n    return this._column;\n  }\n\n  get row() {\n    return this._row;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n}\n\nGem.GENERATE_BADROCK = false;\nexports.Gem = Gem;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Gem.ts\n// module id = 1080\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass MatchSequenceHelper {\n  constructor(gem) {\n    this.add = gem => {\n      let lastElement = this.currentList[this.currentList.length - 1];\n\n      if (gem.row > lastElement.row + 1 || gem.column > lastElement.column + 1) {\n        // ideintify a gap. Like: B B Y B\n        this.end();\n      }\n\n      this.currentList.push(gem);\n    };\n\n    this.type = gem.type;\n    this.currentList = [gem];\n    this.matchList = [];\n  }\n\n  size() {\n    return this.matchList.length;\n  }\n\n  get list() {\n    return this.matchList;\n  }\n\n  end() {\n    if (this.currentList.length > 2) {\n      this.matchList.push(...this.currentList.slice());\n    }\n\n    this.currentList = [];\n  }\n\n}\n\nexports.MatchSequenceHelper = MatchSequenceHelper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/MatchSequenceHelper.ts\n// module id = 1081\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass Coordenate {}\n\nexports.Coordenate = Coordenate;\n\nclass Grid {\n  constructor(coordenate) {\n    this.populate = fillFunction => {\n      for (let c = 0; c < this.numberOfColumns; c++) {\n        for (let l = 0; l < this.numberOfRows; l++) {\n          let item = fillFunction({\n            column: c,\n            row: l\n          });\n          this._columns[c][l] = item;\n        }\n      }\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          this._row[l][c] = this._columns[c][l];\n        }\n      }\n    };\n\n    this.row = index => {\n      return this._row[index];\n    };\n\n    this.column = index => {\n      return this._columns[index];\n    };\n\n    this.cell = coordenate => {\n      return this._columns[coordenate.column][coordenate.row];\n    };\n\n    this.setCell = (coordenate, value) => {\n      this._columns[coordenate.column][coordenate.row] = value;\n      this._row[coordenate.row][coordenate.column] = value;\n    };\n\n    this.sort = func => {\n      this._columns.forEach(column => {\n        column.sort(func);\n      });\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          this._row[l][c] = this._columns[c][l];\n        }\n      }\n    };\n\n    this.createEmptyList = size => {\n      let list = [];\n\n      for (let i = 0; i < size; i++) {\n        list.push([]);\n      }\n\n      ;\n      return list;\n    };\n\n    this.numberOfColumns = coordenate.column;\n    this.numberOfRows = coordenate.row;\n    this._columns = this.createEmptyList(this.numberOfColumns);\n    this._row = this.createEmptyList(this.numberOfRows);\n  }\n\n  get rows() {\n    return this._row.map(e => e.map(g => g));\n  }\n\n  get columns() {\n    return this._columns.map(e => e.map(g => g));\n  }\n\n}\n\nexports.Grid = Grid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Grid.ts\n// module id = 1082\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Resources_1 = require(\"./Resources\");\n\nclass ScoreConstructor {}\n\nclass Score {\n  constructor(cObj) {\n    this.inc = value => {\n      this.score += value;\n      this.text.setText(\"SCORE: \" + (\"000000\" + this.score).slice(-6));\n    };\n\n    this.score = 0;\n    this.x = cObj.x;\n    this.y = cObj.y;\n    this.scene = cObj.scene;\n    this.panel = cObj.scene.add.image(cObj.x, cObj.y, Resources_1.Resources.scorePanel.name);\n    let style = {\n      font: \"bold 40px Courier\",\n      fill: \"#fff\",\n      boundsAlignH: \"center\",\n      boundsAlignV: \"middle\",\n      stroke: '#000000',\n      strokeThickness: 2\n    };\n    this.text = cObj.scene.add.text(cObj.x - 160, cObj.y - 20, \"SCORE: 000000\", style);\n  }\n\n}\n\nexports.Score = Score;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Score.ts\n// module id = 1083\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst IMAGE_PATH = \"./assets/\";\n\nclass Resource {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n  }\n\n}\n\nexports.Resource = Resource;\n\nclass Resources {}\n\nResources.load = (scene, res) => {\n  scene.load.image(res.name, res.url);\n};\n\nResources.background = new Resource(\"background\", IMAGE_PATH + \"background.png\");\nResources.diamondBlue = new Resource(\"diamondBlue\", IMAGE_PATH + \"diamond_blue.png\");\nResources.diamondRed = new Resource(\"diamondRed\", IMAGE_PATH + \"diamond_red.png\");\nResources.diamondGreen = new Resource(\"diamondGreen\", IMAGE_PATH + \"diamond_green.png\");\nResources.diamondYellow = new Resource(\"diamondYellow\", IMAGE_PATH + \"diamond_yellow.png\");\nResources.badrock = new Resource(\"badrock\", IMAGE_PATH + \"diamond_gray.png\");\nResources.scorePanel = new Resource(\"scorePanel\", IMAGE_PATH + \"score_panel.png\");\nexports.Resources = Resources;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Resources.ts\n// module id = 128\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Events;\n\n(function (Events) {\n  Events[Events[\"gemClick\"] = 0] = \"gemClick\";\n})(Events = exports.Events || (exports.Events = {}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Events.ts\n// module id = 435\n// module chunks = 0","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst PlayScene_1 = __importDefault(require(\"./scenes/PlayScene\"));\n\nconst config = {\n  type: Phaser.AUTO,\n  parent: 'content',\n  width: 430,\n  height: 530,\n  resolution: 1,\n  transparent: true,\n  pixelArt: true,\n  scene: [PlayScene_1.default]\n};\nnew Phaser.Game(config);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.ts\n// module id = 437\n// module chunks = 0"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}