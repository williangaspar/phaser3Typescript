{"version":3,"file":"bundle.js","sources":["webpack:///./src/scenes/PlayScene.ts","webpack:///./src/components/GemGrid.ts","webpack:///./src/components/MatchSequenceHelper.ts","webpack:///./src/components/GemFactory.ts","webpack:///./src/components/Bedrock.ts","webpack:///./src/components/Bomb.ts","webpack:///./src/components/Grid.ts","webpack:///./src/components/Score.ts","webpack:///./src/components/Resources.ts","webpack:///./src/components/Gem.ts","webpack:///./src/components/Events.ts","webpack:///./src/components/GemType.ts","webpack:///./src/main.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Resources_1 = require(\"../components/Resources\");\n\nconst GemGrid_1 = require(\"../components/GemGrid\");\n\nconst Score_1 = require(\"../components/Score\");\n\nconst Events_1 = require(\"../components/Events\");\n\nconst GemType_1 = require(\"../components/GemType\");\n\nclass GameScene extends Phaser.Scene {\n  constructor() {\n    super({\n      key: 'GameScene'\n    });\n\n    this.check = (chain = 0) => {\n      this.input.mouse.enabled = false;\n      let match = this.grid.check();\n\n      if (match.length) {\n        let match = this.grid.check();\n        this.grid.remove(match).then(() => {\n          match.forEach((e, idx) => this.score.inc(Math.pow(e.list.length, 2) + (match.length - idx) + Math.pow(chain, 2)));\n          this.grid.repopulate();\n        });\n        setTimeout(() => this.check(chain + 1), 2000);\n      } else {\n        this.checkGameover();\n      }\n    };\n\n    this.checkGameover = () => {\n      if (this.grid.isGameOver()) {\n        if (this.lifes) {\n          this.input.mouse.enabled = true;\n          this.lifes--;\n          this.grid.replacebedrock().then(this.check);\n        } else {\n          this.grid.disableGems();\n          let style = {\n            font: \"bold 50px Courier\",\n            fill: \"#fff\",\n            boundsAlignH: \"center\",\n            boundsAlignV: \"middle\",\n            stroke: '#000000',\n            strokeThickness: 4\n          };\n          let text = this.add.text(this.background.width / 2, this.background.height / 2, \"GAME OVER!\", style);\n          text.setOrigin(0.5, 0.5);\n        }\n      } else {\n        this.input.mouse.enabled = true;\n      }\n    };\n  }\n\n  preload() {\n    Resources_1.Resources.load(this, Resources_1.Resources.background);\n    Resources_1.Resources.load(this, Resources_1.Resources.scorePanel);\n    GemType_1.GEM_LIST.forEach(e => Resources_1.Resources.load(this, e.res));\n  }\n\n  create() {\n    this.lifes = 1;\n    this.background = this.add.image(215, 215, Resources_1.Resources.background.name);\n    this.score = new Score_1.Score({\n      scene: this,\n      x: 215,\n      y: 485\n    });\n    this.grid = new GemGrid_1.GemGrid({\n      x: 40,\n      y: 40,\n      scene: this\n    });\n    this.check();\n    this.input.mouse.capture = true;\n    this.sys.events.on(Events_1.Events.gemClick, gem => {\n      this.gem = gem;\n    });\n    this.sys.events.on(Events_1.Events.updateScene, () => {\n      this.input.mouse.enabled = false;\n      this.grid.fall();\n      this.grid.repopulate();\n      setTimeout(() => {\n        this.check();\n      }, 1000);\n    });\n  }\n\n  update(time, delta) {\n    if (!this.input.mouse.enabled) {\n      return;\n    }\n\n    let pointer = this.input.activePointer;\n\n    if (this.gem) {\n      this.gem.sprite.x = pointer.position.x;\n      this.gem.sprite.y = pointer.position.y;\n      let overlapItem = this.grid.overLappingWith(this.gem, pointer.position);\n\n      if (overlapItem) {\n        this.input.mouse.enabled = false;\n        this.grid.swapPosition(this.gem, overlapItem).then(() => {\n          let checkList = this.grid.check();\n\n          if (checkList.length) {\n            this.check();\n          } else {\n            this.grid.swapPosition(this.gem, overlapItem).then(() => this.input.mouse.enabled = true);\n          }\n\n          ;\n          this.gem = null;\n        });\n      }\n    }\n\n    if (this.gem && !pointer.isDown) {\n      this.gem.backToGridPosition();\n      this.gem = null;\n    }\n  }\n\n}\n\nexports.default = GameScene;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scenes/PlayScene.ts\n// module id = 1080\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst MatchSequenceHelper_1 = require(\"./MatchSequenceHelper\");\n\nconst GemFactory_1 = require(\"./GemFactory\");\n\nconst Grid_1 = require(\"./Grid\");\n\nconst GemType_1 = require(\"./GemType\");\n\nconst SPACING = 70;\n\nclass GemGridConstructor {}\n\nclass GemGrid {\n  constructor(cObj) {\n    this.check = () => {\n      let matchListGrid = [];\n      this.searchSequenceOnGrid(this.grid.rows, matchListGrid);\n      this.searchSequenceOnGrid(this.grid.columns, matchListGrid);\n      return matchListGrid;\n    };\n\n    this.remove = matchList => {\n      matchList.forEach(matchItem => {\n        let gemList = matchItem.list;\n        gemList.forEach(gem => {\n          if (this.grid.cell(gem.cell).item != null) {\n            gem.destroy();\n          }\n\n          ;\n          this.grid.setCell(gem.cell, null);\n        });\n      });\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.fall();\n          resolve();\n        }, 500);\n      });\n    };\n\n    this.repopulate = (excludeList = []) => {\n      this.grid.all().forEach(cell => {\n        if (!cell.item) {\n          let xBegin = cell.column * SPACING + this.x;\n          let yBegin = -((this.grid.numberOfRows - cell.row) * SPACING);\n          let newItem = GemFactory_1.GemFactory.getGem({\n            cell,\n            scene: this.scene,\n            visible: true,\n            x: xBegin,\n            y: yBegin,\n            grid: this.grid\n          }, excludeList);\n          let yFinal = cell.row * SPACING + this.y;\n          this.grid.setCell(cell, newItem);\n          newItem.fallTo(yFinal, newItem.cell.row);\n        }\n\n        ;\n      });\n    };\n\n    this.overLappingWith = (gem, position) => {\n      let possibleMoves = gem.calcPossibleMoves();\n\n      for (let i = 0; i < possibleMoves.length; i++) {\n        let overlapItem = this.grid.cell(possibleMoves[i]).item;\n\n        if (overlapItem && overlapItem.stackable) {\n          let width = overlapItem.sprite.width / 2 - 10;\n          let height = overlapItem.sprite.height / 2 - 10;\n          let xBoundary = [overlapItem.x - width, overlapItem.x + width];\n          let yBoundary = [overlapItem.y - height, overlapItem.y + height];\n          let xOverlapping = position.x > xBoundary[0] && position.x < xBoundary[1];\n          let yOverlapping = position.y > yBoundary[0] && position.y < yBoundary[1];\n          let isOverlapping = xOverlapping && yOverlapping;\n\n          if (isOverlapping) {\n            return overlapItem;\n          }\n\n          ;\n        }\n\n        ;\n      }\n\n      ;\n    };\n\n    this.swapPosition = (gem1, gem2, doMoveSprite = true) => {\n      let x1 = gem1.x;\n      let y1 = gem1.y;\n      let cell1 = gem1.cell;\n      let x2 = gem2.x;\n      let y2 = gem2.y;\n      let cell2 = gem2.cell;\n      this.grid.setCell(cell2, gem1);\n      this.grid.setCell(cell1, gem2);\n      gem1.moveTo({\n        x: x2,\n        y: y2,\n        cell: cell2\n      }, doMoveSprite);\n      gem2.moveTo({\n        x: x1,\n        y: y1,\n        cell: cell1\n      }, doMoveSprite);\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n        }, 500);\n      });\n    };\n\n    this.isGameOver = () => {\n      /*\r\n          This is not a very optimized solution since we will have a lot of\r\n          overlapping check, but it will still been fast sice we don't have\r\n          that many columns and rows\r\n       */\n      let cells = this.grid.all();\n\n      for (let g = 0; g < cells.length; g++) {\n        let cell = cells[g];\n        let gem = cell.item;\n        let possibleMoves = gem.calcPossibleMoves(); // check if any move will result in a match\n\n        for (let i = 0; i < possibleMoves.length; i++) {\n          let swapGem = this.grid.cell(possibleMoves[i]).item;\n\n          if (swapGem.type == GemType_1.GemType.bomb) {\n            return false;\n          }\n\n          if (gem.stackable && swapGem.stackable) {\n            let matchListGrid = [];\n            this.swapPosition(gem, swapGem, false);\n            this.searchSequenceOnGrid([this.grid.row(cell.row)], matchListGrid);\n            this.searchSequenceOnGrid([this.grid.column(cell.column)], matchListGrid);\n\n            if (matchListGrid.length) {\n              // if yes, just go on.\n              this.swapPosition(gem, swapGem);\n              return false;\n            }\n\n            this.swapPosition(gem, swapGem);\n          }\n        }\n\n        ;\n      }\n\n      ; // if no move will result in a match, the game is over!\n\n      return true;\n    };\n\n    this.replacebedrock = () => {\n      return new Promise(resolve => {\n        this.grid.all().forEach(cell => {\n          if (cell.item.type == GemType_1.GemType.bedrock) {\n            cell.item.destroy();\n            this.grid.setCell(cell, null);\n            setTimeout(() => {\n              this.fall();\n              this.repopulate([GemType_1.GemType.bedrock]);\n            }, 500);\n          }\n\n          ;\n        });\n        setTimeout(() => {\n          resolve();\n        }, 1500);\n      });\n    };\n\n    this.disableGems = () => {\n      this.grid.all().forEach(cell => {\n        cell.item.disableClick();\n      });\n    };\n\n    this.fall = () => {\n      this.grid.sortColumnByItem((a, b) => {\n        let aValue = a.item ? 1 : -1;\n        let bValue = b.item ? 1 : -1;\n        return aValue - bValue;\n      });\n      this.grid.all().forEach(cell => {\n        if (cell.item) {\n          cell.item.fallTo(cell.row * SPACING + this.y, cell.row);\n        }\n\n        ;\n      });\n    };\n\n    this.searchSequenceOnGrid = (grid, matchListGrid) => {\n      grid.forEach(e => {\n        let matchList = this.searchSequenceOnList(e, 0, []);\n\n        if (matchList.length) {\n          matchListGrid.push(...matchList);\n        }\n\n        ;\n      });\n    };\n\n    this.searchSequenceOnList = (list, index, matchList) => {\n      let item = list[index].item;\n      let matchItem = matchList.filter(e => e.type == item.type);\n\n      if (matchItem.length) {\n        matchItem[0].add(item);\n      } else if (item.stackable) {\n        let newMatchItem = new MatchSequenceHelper_1.MatchSequenceHelper(item);\n        matchList.push(newMatchItem);\n      }\n\n      ;\n\n      if (index < list.length - 1) {\n        index++;\n        return this.searchSequenceOnList(list, index, matchList);\n      } else {\n        matchList = matchList.filter(e => {\n          e.end();\n          return e.size();\n        });\n        return matchList;\n      }\n\n      ;\n    };\n\n    this.grid = new Grid_1.Grid({\n      column: 6,\n      row: 6\n    });\n    this.grid.populate(cell => {\n      let x = cell.column * SPACING + cObj.x;\n      let y = cell.row * SPACING + cObj.y;\n      let grid = this.grid;\n      let item = GemFactory_1.GemFactory.getGem({\n        cell,\n        scene: cObj.scene,\n        visible: true,\n        x,\n        y,\n        grid\n      }, [GemType_1.GemType.bedrock]);\n      return item;\n    });\n    this.x = cObj.x;\n    this.y = cObj.y;\n    this.scene = cObj.scene;\n  }\n\n}\n\nexports.GemGrid = GemGrid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/GemGrid.ts\n// module id = 1081\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass MatchSequenceHelper {\n  constructor(gem) {\n    this.add = gem => {\n      let lastElement = this.currentList[this.currentList.length - 1];\n\n      if (gem.cell.row > lastElement.cell.row + 1 || gem.cell.column > lastElement.cell.column + 1) {\n        // ideintify a gap. Like: B B Y B\n        this.end();\n      }\n\n      this.currentList.push(gem);\n    };\n\n    this.type = gem.type;\n    this.currentList = [gem];\n    this.matchList = [];\n  }\n\n  size() {\n    return this.matchList.length;\n  }\n\n  get list() {\n    return this.matchList;\n  }\n\n  end() {\n    if (this.currentList.length > 2) {\n      this.matchList.push(...this.currentList.slice());\n    }\n\n    this.currentList = [];\n  }\n\n}\n\nexports.MatchSequenceHelper = MatchSequenceHelper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/MatchSequenceHelper.ts\n// module id = 1082\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Gem_1 = require(\"./Gem\");\n\nconst Bedrock_1 = require(\"./Bedrock\");\n\nconst GemType_1 = require(\"./GemType\");\n\nconst Bomb_1 = require(\"./Bomb\");\n\nclass GemFactory {}\n\nGemFactory.getGem = (gemConstructor, exclude = []) => {\n  let gemList = GemType_1.GEM_LIST.filter(g => !exclude.some(e => e == g.type));\n  let item = GemFactory.getType(gemList);\n\n  if (item.type == GemType_1.GemType.bedrock) {\n    return new Bedrock_1.Bedrock(Object.assign({}, gemConstructor, {\n      typeName: item.res.name,\n      type: item.type\n    }));\n  } else if (item.type == GemType_1.GemType.bomb) {\n    return new Bomb_1.Bomb(Object.assign({}, gemConstructor, {\n      typeName: item.res.name,\n      type: item.type\n    }));\n  } else {\n    return new Gem_1.Gem(Object.assign({}, gemConstructor, {\n      typeName: item.res.name,\n      type: item.type\n    }));\n  }\n};\n\nGemFactory.getType = (gemList, lastType = null, iterations = 0) => {\n  let type = Phaser.Math.Between(0, gemList.length - 1);\n  let item = gemList[type];\n\n  if (item.rare == 0 || item.rare <= iterations) {\n    return item;\n  } else {\n    iterations = lastType == item.type || lastType == null ? iterations + 1 : 1;\n    return GemFactory.getType(gemList, item.type, iterations);\n  }\n};\n\nexports.GemFactory = GemFactory;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/GemFactory.ts\n// module id = 1083\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Gem_1 = require(\"./Gem\");\n\nclass Bedrock extends Gem_1.Gem {\n  constructor(cObj) {\n    super(cObj);\n  }\n\n  setup() {\n    this._stackable = false;\n  }\n\n}\n\nexports.Bedrock = Bedrock;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Bedrock.ts\n// module id = 1084\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Gem_1 = require(\"./Gem\");\n\nconst Events_1 = require(\"./Events\");\n\nclass Bomb extends Gem_1.Gem {\n  constructor(cObj) {\n    super(cObj);\n\n    this.explode = () => {\n      let possibleMoves = this.calcPossibleMoves();\n      possibleMoves.forEach(m => {\n        let gem = this.grid.cell({\n          column: m.column,\n          row: m.row\n        }).item;\n        gem.destroy();\n        this.grid.setCell(gem.cell, null);\n      });\n    };\n  }\n\n  setup() {\n    this.sprite.setInteractive();\n    this._stackable = false;\n    this.sprite.on(\"pointerdown\", () => {\n      if (!this.disabled) {\n        this.onDestroy();\n        this.explode();\n        setTimeout(() => {\n          this.scene.sys.events.emit(Events_1.Events.updateScene);\n        }, 500);\n      }\n    });\n  }\n\n  onDestroy() {\n    this.grid.setCell(this.cell, null);\n    this.tween = this.scene.add.tween({\n      targets: [this.sprite],\n      ease: 'Easing.Bounce.InOut',\n      duration: 300,\n      delay: 0,\n      alpha: {\n        getStart: () => this.sprite.alpha,\n        getEnd: () => 0\n      },\n      scaleX: {\n        getStart: () => this.sprite.scaleX,\n        getEnd: () => 1.3\n      },\n      scaleY: {\n        getStart: () => this.sprite.scaleY,\n        getEnd: () => 1.3\n      },\n      onComplete: () => {\n        this.sprite.destroy();\n      }\n    });\n  }\n\n}\n\nexports.Bomb = Bomb;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Bomb.ts\n// module id = 1085\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass Coordenate {}\n\nexports.Coordenate = Coordenate;\n\nclass Cell extends Coordenate {}\n\nexports.Cell = Cell;\n\nclass Grid {\n  constructor(coordenate) {\n    this.populate = fillFunction => {\n      for (let c = 0; c < this.numberOfColumns; c++) {\n        for (let l = 0; l < this.numberOfRows; l++) {\n          let coordenate = {\n            column: c,\n            row: l\n          };\n          let item = fillFunction(coordenate);\n          this._columns[c][l] = Object.assign({}, coordenate, {\n            item\n          });\n        }\n      }\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          this._row[l][c] = this._columns[c][l];\n        }\n      }\n    };\n\n    this.row = index => {\n      return this._row[index];\n    };\n\n    this.column = index => {\n      return this._columns[index];\n    };\n\n    this.cell = coordenate => {\n      return this._columns[coordenate.column][coordenate.row];\n    };\n\n    this.setCell = (coordenate, item) => {\n      this._columns[coordenate.column][coordenate.row].item = item;\n      this._row[coordenate.row][coordenate.column].item = item;\n    };\n\n    this.sortColumnByItem = func => {\n      this._columns.forEach(column => {\n        column.sort(func);\n      });\n\n      for (let c = 0; c < this.numberOfColumns; c++) {\n        for (let l = 0; l < this.numberOfRows; l++) {\n          let coordenate = {\n            column: c,\n            row: l\n          };\n          this._columns[c][l] = Object.assign({}, coordenate, {\n            item: this._columns[c][l].item\n          });\n        }\n      }\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          this._row[l][c] = this._columns[c][l];\n        }\n      }\n    };\n\n    this.filter = func => {\n      let list = [];\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          if (func(this._columns[c][l])) {\n            list.push(this._columns[c][l]);\n          }\n\n          ;\n        }\n\n        ;\n      }\n\n      ;\n      return list;\n    };\n\n    this.all = () => {\n      let list = [];\n\n      for (let l = 0; l < this.numberOfColumns; l++) {\n        for (let c = 0; c < this.numberOfRows; c++) {\n          list.push(this._columns[c][l]);\n        }\n\n        ;\n      }\n\n      ;\n      return list;\n    };\n\n    this.createEmptyList = size => {\n      let list = [];\n\n      for (let i = 0; i < size; i++) {\n        list.push([]);\n      }\n\n      ;\n      return list;\n    };\n\n    this.numberOfColumns = coordenate.column;\n    this.numberOfRows = coordenate.row;\n    this._columns = this.createEmptyList(this.numberOfColumns);\n    this._row = this.createEmptyList(this.numberOfRows);\n  }\n\n  get rows() {\n    return this._row.map(e => e.map(g => g));\n  }\n\n  get columns() {\n    return this._columns.map(e => e.map(g => g));\n  }\n\n}\n\nexports.Grid = Grid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Grid.ts\n// module id = 1086\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Resources_1 = require(\"./Resources\");\n\nclass ScoreConstructor {}\n\nclass Score {\n  constructor(cObj) {\n    this.inc = value => {\n      this.score += value;\n      this.text.setText(\"SCORE: \" + (\"000000\" + this.score).slice(-6));\n    };\n\n    this.score = 0;\n    this.x = cObj.x;\n    this.y = cObj.y;\n    this.scene = cObj.scene;\n    this.panel = cObj.scene.add.image(cObj.x, cObj.y, Resources_1.Resources.scorePanel.name);\n    let style = {\n      font: \"bold 40px Courier\",\n      fill: \"#fff\",\n      boundsAlignH: \"center\",\n      boundsAlignV: \"middle\",\n      stroke: '#000000',\n      strokeThickness: 2\n    };\n    this.text = cObj.scene.add.text(cObj.x - 160, cObj.y - 20, \"SCORE: 000000\", style);\n  }\n\n}\n\nexports.Score = Score;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Score.ts\n// module id = 1087\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst IMAGE_PATH = \"./assets/\";\n\nclass Resource {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n  }\n\n}\n\nexports.Resource = Resource;\n\nclass Resources {}\n\nResources.load = (scene, res) => {\n  scene.load.image(res.name, res.url);\n};\n\nResources.background = new Resource(\"background\", IMAGE_PATH + \"background.png\");\nResources.diamondBlue = new Resource(\"diamondBlue\", IMAGE_PATH + \"diamond_blue.png\");\nResources.diamondRed = new Resource(\"diamondRed\", IMAGE_PATH + \"diamond_red.png\");\nResources.diamondGreen = new Resource(\"diamondGreen\", IMAGE_PATH + \"diamond_green.png\");\nResources.diamondYellow = new Resource(\"diamondYellow\", IMAGE_PATH + \"diamond_yellow.png\");\nResources.bomb = new Resource(\"bomb\", IMAGE_PATH + \"bomb.png\");\nResources.bedrock = new Resource(\"bedrock\", IMAGE_PATH + \"diamond_gray.png\");\nResources.scorePanel = new Resource(\"scorePanel\", IMAGE_PATH + \"score_panel.png\");\nexports.Resources = Resources;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Resources.ts\n// module id = 211\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst Events_1 = require(\"./Events\");\n\nclass GemFactoryonstructor {}\n\nexports.GemFactoryonstructor = GemFactoryonstructor;\n\nclass GemConstructor extends GemFactoryonstructor {}\n\nexports.GemConstructor = GemConstructor;\n\nclass MoveTo {}\n\nclass Gem {\n  constructor(cObj) {\n    this.disabled = false;\n\n    this.moveTo = (obj, moveSprite = true) => {\n      this._x = obj.x;\n      this._y = obj.y;\n      this._cell = obj.cell;\n\n      if (moveSprite) {\n        this.backToGridPosition();\n      }\n\n      ;\n    };\n\n    this.fallTo = (y, row) => {\n      this._cell.row = row;\n      this._y = y;\n      this.tween = this.scene.add.tween({\n        targets: [this.sprite],\n        ease: 'Sine.Quadratic.Out',\n        duration: 200 + y - this.sprite.y,\n        delay: 0,\n        y: {\n          getStart: () => this.sprite.y,\n          getEnd: () => y\n        }\n      });\n    };\n\n    this.backToGridPosition = () => {\n      this.tween = this.scene.add.tween({\n        targets: [this.sprite],\n        ease: 'Sine.easeInOut',\n        duration: 100 + (Math.abs(this.sprite.y - this._y) + Math.abs(this.sprite.x - this._y)) / 2,\n        delay: 0,\n        y: {\n          getStart: () => this.sprite.y,\n          getEnd: () => this._y\n        },\n        x: {\n          getStart: () => this.sprite.x,\n          getEnd: () => this._x\n        }\n      });\n    };\n\n    this.disableClick = () => {\n      /*\r\n          The only line really working here is the last one\r\n          idk why, but on mobile the first 2 lines have no effect\r\n      */\n      this.sprite.setInteractive(false);\n      this.sprite.on(\"pointerdown\", () => {});\n      this.disabled = true;\n    };\n\n    this.destroy = () => {\n      this.onDestroy();\n    };\n\n    this.calcPossibleMoves = () => {\n      let maxBoudaryColumns = this.grid.columns.length;\n      let maxBoudaryRows = this.grid.rows.length;\n      let moves = [];\n\n      if (this.cell.column - 1 > -1) {\n        //move to the left\n        moves.push({\n          column: this.cell.column - 1,\n          row: this.cell.row\n        });\n      }\n\n      ;\n\n      if (this.cell.column + 1 < maxBoudaryColumns) {\n        //move to the right\n        moves.push({\n          column: this.cell.column + 1,\n          row: this.cell.row\n        });\n      }\n\n      ;\n\n      if (this.cell.row - 1 > -1) {\n        //move to the top\n        moves.push({\n          column: this.cell.column,\n          row: this.cell.row - 1\n        });\n      }\n\n      ;\n\n      if (this.cell.row + 1 < maxBoudaryRows) {\n        //move to the bottom\n        moves.push({\n          column: this.cell.column,\n          row: this.cell.row + 1\n        });\n      }\n\n      ;\n      return moves;\n    };\n\n    this.type = cObj.type;\n    this.grid = cObj.grid;\n    this.sprite = cObj.scene.add.image(cObj.x, cObj.y, cObj.typeName);\n    this.sprite.visible = cObj.visible;\n    this._cell = cObj.cell;\n    this.scene = cObj.scene;\n    this._x = cObj.x;\n    this._y = cObj.y;\n    this.setup();\n  }\n\n  setup() {\n    this._stackable = true;\n    this.sprite.setInteractive();\n    this.sprite.on(\"pointerdown\", () => {\n      if (!this.disabled) {\n        this.scene.children.bringToTop(this.sprite);\n        this.scene.sys.events.emit(Events_1.Events.gemClick, this);\n      }\n    });\n  }\n\n  get cell() {\n    return this._cell;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  get stackable() {\n    return this._stackable;\n  }\n\n  onDestroy() {\n    this.tween = this.scene.add.tween({\n      targets: [this.sprite],\n      ease: 'Sine.easeInOut',\n      duration: 500,\n      delay: 0,\n      alpha: {\n        getStart: () => this.sprite.alpha,\n        getEnd: () => 0\n      },\n      scaleX: {\n        getStart: () => this.sprite.scaleX,\n        getEnd: () => 0.1\n      },\n      scaleY: {\n        getStart: () => this.sprite.scaleY,\n        getEnd: () => 0.1\n      },\n      onComplete: () => {\n        this.sprite.destroy();\n      }\n    });\n  }\n\n}\n\nexports.Gem = Gem;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Gem.ts\n// module id = 212\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Events;\n\n(function (Events) {\n  Events[Events[\"gemClick\"] = 0] = \"gemClick\";\n  Events[Events[\"updateScene\"] = 1] = \"updateScene\";\n})(Events = exports.Events || (exports.Events = {}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Events.ts\n// module id = 213\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Resources_1 = require(\"./Resources\");\n\nvar GemType;\n\n(function (GemType) {\n  GemType[GemType[\"blue\"] = 0] = \"blue\";\n  GemType[GemType[\"red\"] = 1] = \"red\";\n  GemType[GemType[\"green\"] = 2] = \"green\";\n  GemType[GemType[\"yellow\"] = 3] = \"yellow\";\n  GemType[GemType[\"bedrock\"] = 4] = \"bedrock\";\n  GemType[GemType[\"bomb\"] = 5] = \"bomb\";\n})(GemType = exports.GemType || (exports.GemType = {}));\n\nclass GemResource {}\n\nexports.GemResource = GemResource;\nexports.GEM_LIST = [{\n  type: GemType.blue,\n  res: Resources_1.Resources.diamondBlue,\n  rare: 0\n}, {\n  type: GemType.red,\n  res: Resources_1.Resources.diamondRed,\n  rare: 0\n}, {\n  type: GemType.green,\n  res: Resources_1.Resources.diamondGreen,\n  rare: 0\n}, {\n  type: GemType.yellow,\n  res: Resources_1.Resources.diamondYellow,\n  rare: 0\n}, {\n  type: GemType.bedrock,\n  res: Resources_1.Resources.bedrock,\n  rare: 1\n}, {\n  type: GemType.bomb,\n  res: Resources_1.Resources.bomb,\n  rare: 2\n}];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/GemType.ts\n// module id = 214\n// module chunks = 0","\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"phaser\");\n\nconst PlayScene_1 = __importDefault(require(\"./scenes/PlayScene\"));\n\nconst config = {\n  type: Phaser.AUTO,\n  parent: 'content',\n  width: 430,\n  height: 530,\n  resolution: 1,\n  transparent: true,\n  pixelArt: true,\n  scene: [PlayScene_1.default]\n};\nnew Phaser.Game(config);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.ts\n// module id = 439\n// module chunks = 0"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}